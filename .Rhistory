# Set the 'RowNames' column as row names
rownames(train_data) <- train_data$subjid
# Remove the 'RowNames' column
train_data <- train_data[, -which(names(train_data) == "subjid")]
train_data
file_path_participant <- "../../related_material/dataset/obesity/ST002269_data_metadata.csv"
file_path_metabolite <- "../../related_material/dataset/obesity/ST002269_data_mets.csv"
file_ext <- "csv"
participant_data <- read_file(file_path = file_path_participant,
file_ext = file_ext)
metabolite_data <- read_file(file_path = file_path_metabolite,
file_ext = file_ext)
processed_data <- pre_process(participant_data = participant_data,
metabolite_data = metabolite_data,
metabolite_ids_are_rows = FALSE,
case_control_col="nafld")
participant_data_out <- processed_data$participant_data
metabolite_data_out <- processed_data$metabolite_data
combined_data <- processed_data$combined_data
train_data <- processed_data$train
test_data <- processed_data$test
# Set the 'RowNames' column as row names
rownames(train_data) <- train_data$subjid
# Remove the 'RowNames' column
train_data <- train_data[, -which(names(train_data) == "subjid")]
primary_outcome <- "nafld"
ip_weights <- get_weights(train_data, primary_outcome)
alpha <- 0.5
cv_iter <- 5
secondary_outcome <- "obesity"
x <- model.matrix(as.factor(secondary_outcome) ~ . - 1, data = train_data)  # Create model matrix (no intercept)
x <- model.matrix(as.factor(secondary_outcome) ~ . - 1, data = metabolite_data)  # Create model matrix (no intercept)
# Set the 'RowNames' column as row names
rownames(metabolite_data) <- metabolite_data$subjid
# Remove the 'RowNames' column
metabolite_data <- metabolite_data[, -which(names(metabolite_data) == "subjid")]
x <- model.matrix(as.factor(secondary_outcome) ~ . - 1, data = metabolite_data)  # Create model matrix (no intercept)
metabolite_data
train_data
x <- model.matrix(as.factor(secondary_outcome) ~ . - 1, data = train_data)  # Create model matrix (no intercept)
secondary_outcome <- "obesity"
x <- model.matrix(as.factor(secondary_outcome) ~ . - 1, data = train_data)  # Create model matrix (no intercept)
x <- model.matrix(secondary_outcome ~ . - 1, data = train_data)  # Create model matrix (no intercept)
sapply(train_data, length)
sum(sapply(train_data, length) != 97)
train_data
head(colnames(train_data))
secondary_outcome <- "obese"
x <- model.matrix(as.factor(secondary_outcome) ~ . - 1, data = train_data)  # Create model matrix (no intercept)
train_data
x <- model.matrix(as.factor("obese") ~ . - 1, data = train_data)  # Create model matrix (no intercept)
x <- model.matrix(as.factor(age) ~ . - 1, data = train_data)  # Create model matrix (no intercept)
x <- model.matrix(as.factor(one_of(secondary_outcome)) ~ . - 1, data = train_data)  # Create model matrix (no intercept)
x <- model.matrix(as.factor(obese) ~ . - 1, data = train_data)  # Create model matrix (no intercept)
# Define the secondary outcome variable
secondary_outcome <- "obese"  # Example value, change based on your data
# Create the model matrix using a dynamic formula
x <- model.matrix(as.formula(paste(secondary_outcome, "~ . - 1")), data = train_data)
# View the result
print(x)
x <- model.matrix(as.factor(secondary_outcome) ~ . - 1, data = train_data)  # Create model matrix (no intercept)
y <- as.factor(train_data$secondary_outcome)  # Outcome variable (factor)
x <- model.matrix(as.factor(secondary_outcome) ~ . - 1, data = train_data)  # Create model matrix (no intercept)
x <- model.matrix(as.formula(paste(secondary_outcome, "~ . - 1")), data = train_data)  # Create model matrix (no intercept)
y <- as.factor(train_data$secondary_outcome)  # Outcome variable (factor)
cv_fit <- cv.glmnet(x, y, family = "binomial", alpha = alpha, weights = weights, nfolds = cv_iter)
weights()
ip_weights <- get_weights(train_data, primary_outcome)
# Step 2: Get Weights (if applicable, based on outcomes)
ip_weights <- get_weights(train_data, primary_outcome)
cv_fit <- cv.glmnet(x, y, family = "binomial", alpha = alpha, weights = ip_weights$values, nfolds = cv_iter)
y <- as.factor(train_data$secondary_outcome)  # Outcome variable (factor)
y <- as.factor(train_data[[secondary_outcome]])  # Outcome variable (factor)
cv_fit <- cv.glmnet(x, y, family = "binomial", alpha = alpha, weights = ip_weights$values, nfolds = cv_iter)
# Step 1: Extract the coefficients at the best lambda
coef_matrix <- coef(cv_fit, s = "lambda.min")
coef_df <- as.data.frame(as.matrix(coef_matrix))
coef_df$feature <- rownames(coef_df)
colnames(coef_df)[1] <- "coefficient"
coef_df <- coef_df %>% filter(feature != "(Intercept)")  # Remove intercept
# Step 2: Get the top 10 coefficients by absolute value (excluding intercept)
top_ten_coef <- coef_df %>%
arrange(desc(abs(coefficient))) %>%
head(10)
# Step 3: Calculate AUC-ROC on the training data
y_pred <- predict(cv_fit, newx = x, s = "lambda.min", type = "response")
roc_obj <- roc(y, y_pred)  # Calculate ROC curve
# Step 4: Calculate the AUC value and 95% confidence interval for AUC
auc_value <- auc(roc_obj)  # AUC value
auc_ci <- ci.auc(roc_obj)  # 95% Confidence interval
# Step 5: Plot ROC curve with ggplot2 and add 95% CI
roc_plot <- ggroc(roc_obj) +
geom_line(size = 1) +
ggtitle(paste("ROC Curve (AUC = ", round(auc_value, 3), ")", sep = "")) +
theme_minimal() +
annotate("text", x = 0.8, y = 0.2,
label = paste0("AUC 95% CI: (",
round(auc_ci[1], 3), ", ",
round(auc_ci[3], 3), ")"),
size = 5, hjust = 0)
# Return the top ten coefficients, AUC value, and the ROC curve plot
return(list(
top_ten_coefficients = top_ten_coef,
auc_value = auc_value,
auc_ci = auc_ci,
roc_plot = roc_plot
))
results <- list(
top_ten_coefficients = top_ten_coef,
auc_value = auc_value,
auc_ci = auc_ci,
roc_plot = roc_plot
)
results$top_ten_coefficients
results$roc_plot
prin(results$roc_plot)
print(results$roc_plot)
devtools::load_all(".")
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
#Loading necessary libraries
library(tidyverse)
library(lme4)
library(lmerTest)
# Setting the knitr options. Supressing the warnings and messages in the output.
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
#Reading the dataset
df <- read.csv("../../../../data/input/UltraEndurance_and_EM_Analysis_Merged_new.csv")
#Selecting columns with less than 20% missing values.
df_altered <- df[(colSums(is.na(df)) / nrow(df)) * 100 < 20]
#Renaming the column
colnames(df_altered)[7] <- "time"
1:8
1:7
#Centering and Scaling the data
df_altered[, -(1:8)] <- scale(df_altered[, -(1:8)])
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
?app_server
#' The application server-side
#'
#' @param input,output,session Internal parameters for {shiny}.
#'     DO NOT REMOVE.
#' @import shiny
#' @noRd
app_server <- function(input, output, session) {
r <- reactiveValues()
# Capture the first select input value
r$selected_first <- reactive({
input$firstSelect
})
# Capture the radio button value (Yes/No)
r$is_designed_for_another_outcome <- reactive({
input$fav_language  # This will return "True" or "False" based on the selected radio button
})
# Capture the second select input value
r$selected_second <- reactive({
input$secondSelect
})
# Capture selected checkboxes as a vector
r$selected_checkboxes <- reactive({
input$adjust_factors  # This will be a vector of selected checkbox values
})
# Observe the inputs and print for debugging purposes
observe({
req(input$firstSelect, input$secondSelect)
# Debugging: Print the selected inputs
print(paste("Selected First Select:", input$firstSelect))
print(paste("Radio Button (Another Outcome):", input$nao))
print(paste("Radio Button (Another Outcome):", input$yaes))
print(paste("Selected Second Select:", input$secondSelect))
# Print selected checkboxes (vector)
if (!is.null(input$adjust_factors)) {
print(paste("Selected Checkboxes:", paste(input$adjust_factors, collapse = ", ")))
} else {
print("No checkboxes selected.")
}
})
# Cache the UI so that it can be reused when navigating back to page 5
cached_analysis_ui <- reactiveVal()
analysis_values <- reactiveVal()
# Helper function to render analysis page with the analysis module UI
render_analysis_page <- function(r) {
if (is.null(cached_analysis_ui())) {
output$pageContent <- renderUI({
htmlTemplate(
app_sys("app/www/page5_analysis.html"),
display_analysis_results = mod_view_analysis_ui("view_analysis_1")
)
})
r$complete_analysis_results <- mod_view_analysis_server("view_analysis_1", r = r)
# Use observe or another reactive context to access the reactive value
observe({
req(r$complete_analysis_results())
analysis_values(r$complete_analysis_results())
})
cached_analysis_ui(TRUE)
} else {
output$pageContent <- renderUI({
htmlTemplate(
app_sys("app/www/page5_analysis.html"),
display_analysis_results = mod_view_analysis_ui("view_analysis_1")
)
})
}
}
# Load the initial page (Home Page)
output$pageContent <- renderUI({
htmlTemplate(app_sys("app/www/page0_landing.html"))
})
# Observe when "Go to Page 1" is clicked
observeEvent(input$get_started, {
output$pageContent <- renderUI({
htmlTemplate(app_sys("app/www/page1_welcome.html"))
})
})
# Observe when "continue" is clicked
observeEvent(input$continue, {
output$pageContent <- renderUI({
htmlTemplate(
app_sys("app/www/page2_upload.html"),
metabolomics_data_upload = mod_metabolomics_upload_ui("metabolomics_upload"),
participant_data_upload = mod_participant_upload_ui("participant_upload"),
select_one_of_rows_or_columns = mod_metabolite_along_ui("metabolite_along_1")
)
})
})
# Capture dataset and dataset columns when participant data is uploaded
r$participant_data <- mod_participant_upload_server("participant_upload")
# Capture dataset and dataset columns when metabolomics data is uploaded
r$metabolomics_data <- mod_metabolomics_upload_server("metabolomics_upload")
# Capture if metabolites are recorded along rows or columns of the dataset
r$metabolites_are_rows <- mod_metabolite_along_server("metabolite_along_1")
# Handle navigation to Page 3 (outcomes)
observeEvent(input$next3, {
output$pageContent <- renderUI({
htmlTemplate(
app_sys("app/www/page3_outcomes.html")
)
})
# Ensure columns are available before initializing modules
observe({
# req(r$participant_data$participant_dataset_columns())  # Ensure dataset columns are available
# You can access the values like this:
req(r$selected_first())
req(r$is_designed_for_another_outcome())
req(r$selected_second())
# Access selected checkboxes
req(r$selected_checkboxes())
# Debugging or logic: Print the selected checkboxes
print(paste("Selected Checkboxes:", paste(r$selected_checkboxes(), collapse = ", ")))
# For debugging or logic, you can print or work with these values:
print(paste("Selected First:", r$selected_first()))
print(paste("Designed for Another Outcome:", r$is_designed_for_another_outcome()))
print(paste("Selected Second:", r$selected_second()))
})
})
# Handle navigation to Page 4 (parameters)
observeEvent(input$next4, {
output$pageContent <- renderUI({
htmlTemplate(
app_sys("app/www/page4_parameters.html"),
select_number_of_cv_iterations = mod_select_number_of_cv_iterations_ui("select_number_of_cv_iterations_1"),
select_alpha_value = mod_select_alpha_value_ui("select_alpha_value_1")
)  # Load Page 4
})
})
# Get the cv_iter value
r$cv_iter <- mod_select_number_of_cv_iterations_server("select_number_of_cv_iterations_1")
# Get the alpha value
r$alpha <- mod_select_alpha_value_server("select_alpha_value_1")
# Handle navigation to Page 5 (view analysis)
observeEvent(input$next5, {
req(
r$participant_data$participant_dataset_columns(),
r$metabolomics_data$metabolomics_dataset_columns(),
r$metabolites_are_rows(),
r$primary_outcome(),
r$secondary_outcome(),
r$cv_iter(),
r$alpha()
)
render_analysis_page(
# participant_data_in = r$participant_data,
# metabolomics_data_in = r$metabolomics_data,
# metabolites_are_rows_in = r$metabolites_are_rows,
# selected_primary_outcome_in = selected_primary_outcome,
# selected_secondary_outcome_in = selected_secondary_outcome,
# cv_iter_in = r$cv_iter,
# alpha_in = r$alpha
r = r
)  # Call the helper function to render the analysis page
})
# Handle navigation to Page 6 (downloads)
observeEvent(input$next6, {
output$pageContent <- renderUI({
htmlTemplate(
app_sys("app/www/page6_downloads.html"),
download_ipw_button = mod_download_ipw_ui("download_ipw_1"),
# Add the IPW download button here
download_model_coefficients = mod_download_model_coefficients_ui("download_model_coefficients_1"),
download_univariate_analysis = mod_download_univariate_analysis_ui("download_univariate_analysis_1"),
download_smd_analysis = mod_download_smd_analysis_ui("download_smd_analysis_1")
)
})
})
# Handle navigation back to Page 5 (analysis)
observeEvent(input$back5, {
render_analysis_page()  # Ensure the page is rendered properly when going back
})
# Handle navigation back to Page 4 (parameters)
observeEvent(input$back4, {
output$pageContent <- renderUI({
htmlTemplate(
app_sys("app/www/page4_parameters.html"),
select_number_of_cv_iterations = mod_select_number_of_cv_iterations_ui("select_number_of_cv_iterations_1"),
select_alpha_value = mod_select_alpha_value_ui("select_alpha_value_1")
)  # Load Page 4
})
})
# Handle navigation back to Page 3 (outcomes)
observeEvent(input$back3, {
output$pageContent <- renderUI({
htmlTemplate(
app_sys("app/www/page3_outcomes.html")
)  # Load Page 3
})
# Ensure columns are available before initializing modules
observe({
req(r$participant_data$participant_dataset_columns())  # Ensure dataset columns are available
# Call the "select outcome of interest" module and capture the selected primary outcome
selected_outcome_of_interest <- mod_select_outcome_of_interest_server("select_outcome_of_interest_1", r = r)
# Call the secondary outcome module and pass the selected primary outcome
is_designed_for_another_outcome_input <- mod_is_designed_for_another_outcome_server("is_designed_for_another_outcome_1",
r = r)
# Store the selected primary and secondary outcomes in reactive values
r$outcome_of_interest <- selected_outcome_of_interest
r$designed_for_another_outcome <- is_designed_for_another_outcome_input
})
})
# Handle navigation back to Page 2 (upload)
observeEvent(input$back2, {
output$pageContent <- renderUI({
htmlTemplate(
app_sys("app/www/page2_upload.html"),
metabolomics_data_upload = mod_metabolomics_upload_ui("metabolomics_upload"),
participant_data_upload = mod_participant_upload_ui("participant_upload"),
select_one_of_rows_or_columns = mod_metabolite_along_ui("metabolite_along_1")
)  # Load Page 2
})
})
# Handle navigation back to Page 1 (welcome)
observeEvent(input$back1, {
output$pageContent <- renderUI({
htmlTemplate(app_sys("app/www/page1_welcome.html"))  # Load Page 1
})
})
# Observe when "Back to Home" is clicked
observeEvent(input$back_to_home, {
output$pageContent <- renderUI({
htmlTemplate(app_sys("app/www/page0_landing.html"))  # Load Home Page again
})
})
# Set up JavaScript to listen for link clicks and notify Shiny
session$sendCustomMessage(type = 'init', message = NULL)
# Call the server logic for the modules using moduleServer
mod_metabolomics_upload_server("metabolomics_upload")
mod_participant_upload_server("participant_upload")
# Call primary and secondary outcome server modules
# selected_primary_outcome <- mod_select_primary_outcome_server("select_primary_outcome_1", r = r)
# mod_select_secondary_outcome_server("select_secondary_outcome_1", selected_primary_outcome, r = r)
observe({
req(analysis_values())
# IPW download functionality
mod_download_ipw_server("download_ipw_1",data_with_weights = analysis_values()$ip_weights$data_with_weights)
# Model Coefficients functionality
mod_download_model_coefficients_server("download_model_coefficients_1",data_model_coefficients = analysis_values()$multivariate_results$all_coefficients)
# Univariate Analysis functionality
mod_download_univariate_analysis_server("download_univariate_analysis_1",data_univariate_results = analysis_values()$univariate_results$results)
#SMD Analysis
mod_download_smd_analysis_server("download_smd_analysis_1",data_smd = analysis_values()$smd_results )
})
#Metabolite ID's along
mod_metabolite_along_server("metabolite_along_1")
}
?app_server
??app_server
help(":")
?input
??input
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
devtools::load_all(".")
run_app()
